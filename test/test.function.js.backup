import {expect} from 'chai';
import {JSDOM} from 'jsdom';
import JTLT from '../src/index-node.js';

describe('function() - XSLT-like stylesheet functions', function () {
  it('should register and call a simple function', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {x: 5},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          // Register function
          this.function({
            name: 'f:double',
            params: [{name: 'n'}],
            body: (n) => n * 2
          });

          // Call function
          const result = this.invokeFunctionByArity('f:double', [10]);
          this.string(`Result: ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Result: 20');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should require namespaced function names', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          try {
            this.function({
              name: 'double', // no namespace!
              body: (n) => n * 2
            });
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'must be in a namespace'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should support Q{uri}name notation', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'Q{http://example.com}triple',
            params: [{name: 'n'}],
            body: (n) => n * 3
          });

          const result = this.invokeFunctionByArity('Q{http://example.com}triple', [7]);
          this.string(`${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('21');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should handle multiple parameters', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'math:add',
            params: [{name: 'a'}, {name: 'b'}],
            body: (a, b) => a + b
          });

          const result = this.invokeFunctionByArity('math:add', [5, 7]);
          this.string(`Sum: ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Sum: 12');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should handle zero parameters', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'util:constant',
            body: () => 42
          });

          const result = this.invokeFunctionByArity('util:constant', []);
          this.string(`${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('42');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should distinguish functions by arity', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          // Register two functions with same name but different arity
          this.function({
            name: 'f:greet',
            params: [{name: 'name'}],
            body: (name) => `Hello, ${name}!`
          });

          this.function({
            name: 'f:greet',
            params: [{name: 'title'}, {name: 'name'}],
            body: (title, name) => `Hello, ${title} ${name}!`
          });

          const result1 = this.invokeFunctionByArity('f:greet', ['Alice']);
          const result2 = this.invokeFunctionByArity('f:greet', ['Dr.', 'Smith']);
          this.string(`${result1} ${result2}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Hello, Alice!');
          expect(result).to.include('Hello, Dr. Smith!');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should throw error for duplicate function registration', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'f:test',
            params: [{name: 'x'}],
            body: (x) => x
          });

          try {
            this.function({
              name: 'f:test',
              params: [{name: 'y'}], // same arity
              body: (y) => y * 2
            });
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'already registered'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should throw error when calling undefined function', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          try {
            this.invokeFunctionByArity('f:undefined', [1, 2, 3]);
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'not found'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should throw error for wrong arity', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'f:test',
            params: [{name: 'x'}, {name: 'y'}],
            body: (x, y) => x + y
          });

          try {
            // Try calling with wrong number of arguments
            this.invokeFunctionByArity('f:test', [1]); // needs 2 args
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'not found'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should return complex values', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'json',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'data:makeObject',
            params: [{name: 'key'}, {name: 'value'}],
            body: (key, value) => ({[key]: value})
          });

          const obj = this.invokeFunctionByArity('data:makeObject', ['name', 'Alice']);
          // eslint-disable-next-line unicorn/no-this-assignment -- Closure
          const that = this;
          this.object(function () {
            that.propValue('result', obj);
          });
        }
      }],
      success (result) {
        try {
          expect(result).to.deep.equal([{result: {name: 'Alice'}}]);
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  // TODO: Fix XPath test - need to figure out proper way to get text content
  it.skip('should work with XPath context', (done) => {
    const {window} = new JSDOM('<!doctype html><html><body></body></html>');
    const parser = new window.DOMParser();
    const doc = parser.parseFromString(
      '<root><item>5</item></root>',
      'text/xml'
    );

    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: doc,
      engineType: 'xpath',
      xpathVersion: 1,
      outputType: 'string',
      templates: [{
        path: '/root',
        template () {
          this.function({
            name: 'math:square',
            params: [{name: 'n'}],
            body: (n) => n * n
          });

          // Use XPath string() function to get text value
          const value = Number(this.valueOf({select: 'string(item)'}));
          const result = this.invokeFunctionByArity('math:square', [value]);
          this.string(`${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('25');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should be callable from different templates', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {items: [1, 2, 3]},
      outputType: 'string',
      templates: [
        {
          path: '$',
          template () {
            // Register function once at root
            this.function({
              name: 'f:format',
              params: [{name: 'n'}],
              body: (n) => {
                return `[${n}]`;
              }
            });

            // Apply templates to items
            this.applyTemplates({select: '$.items[*]'});
          }
        },
        {
          path: '$.items[*]',
          template (item) {
            // Call function from item template
            const formatted = this.invokeFunctionByArity('f:format', [item]);
            this.string(formatted);
            this.string(' ');
          }
        }
      ],
      success (result) {
        try {
          expect(result).to.equal('[1] [2] [3] ');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should support recursive functions', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          // Recursive factorial function
          // eslint-disable-next-line unicorn/no-this-assignment -- Closure
          const that = this;
          this.function({
            name: 'math:factorial',
            params: [{name: 'n'}],
            body (n) {
              if (n <= 1) {
                return 1;
              }
              // Recursive call via callFunction
              return n * that.invokeFunctionByArity('math:factorial', [n - 1]);
            }
          });

          const result = that.invokeFunctionByArity('math:factorial', [5]);
          that.string(`5! = ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('5! = 120');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should handle functions with context access', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {threshold: 10},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          const threshold = this.get('$.threshold', false);

          this.function({
            name: 'app:isAboveThreshold',
            params: [{name: 'value'}],
            body: (value) => value > threshold
          });

          const result1 = this.invokeFunctionByArity('app:isAboveThreshold', [15]);
          const result2 = this.invokeFunctionByArity('app:isAboveThreshold', [5]);
          this.string(
            `15>${threshold}: ${result1}, 5>${threshold}: ${result2}`
          );
        }
      }],
      success (result) {
        try {
          expect(result).to.include('15>10: true');
          expect(result).to.include('5>10: false');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should work with parameter type hints (as attribute)', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'str:length',
            params: [{name: 's', as: 'xs:string'}],
            as: 'xs:integer',
            body: (s) => String(s).length
          });

          const result = this.invokeFunctionByArity('str:length', ['hello']);
          this.string(`Length: ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Length: 5');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  // TODO: Fix forEach+callTemplate test - investigate why items are output
  it.skip('should work with callTemplate inside forEach', (done) => {
    // Test that functions can be called from within callTemplate
    // invoked inside forEach
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {items: [1, 2, 3]},
      outputType: 'string',
      templates: [
        {
          path: '$',
          template () {
            // Register function
            this.function({
              name: 'f:bracket',
              params: [{name: 'n'}],
              body: (n) => `[${n}]`
            });

            // Use forEach with callTemplate
            this.forEach('$.items[*]', function (item) {
              this.callTemplate({
                name: 'formatter',
                withParam: [{name: 'value', value: item}]
              });
            });
          }
        },
        {
          name: 'formatter',
          template () {
            const val = this.valueOf({select: '$value'});
            try {
              const formatted = this.invokeFunctionByArity('f:bracket', [val]);
              this.string(formatted);
              this.string(' ');
            } catch (err) {
              // Debug: output error
              this.string(`ERROR:${/** @type {Error} */ (err).message} `);
            }
          }
        }
      ],
      success (result) {
        try {
          expect(result).to.equal('[1] [2] [3] ');
          done();
        } catch (err) {
          // Show actual result for debugging
          console.log('Actual result:', result);
          done(err);
        }
      }
    });
  });
});
