import {expect} from 'chai';
import JTLT from '../src/index-node.js';

describe('function() - XSLT-like stylesheet functions', function () {
  it('should register and call a simple function', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {x: 5},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          // Register function
          this.function({
            name: 'f:double',
            params: [{name: 'n'}],
            body: (n) => n * 2
          });

          // Call function
          const result = this.callFunction('f:double', [10]);
          this.string(`Result: ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Result: 20');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should require namespaced function names', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          try {
            this.function({
              name: 'double', // no namespace!
              body: (n) => n * 2
            });
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'must be in a namespace'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should support Q{uri}name notation', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'Q{http://example.com}triple',
            params: [{name: 'n'}],
            body: (n) => n * 3
          });

          const result = this.callFunction('Q{http://example.com}triple', [7]);
          this.string(`${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('21');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should handle multiple parameters', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'math:add',
            params: [{name: 'a'}, {name: 'b'}],
            body: (a, b) => a + b
          });

          const result = this.callFunction('math:add', [5, 7]);
          this.string(`Sum: ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Sum: 12');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should handle zero parameters', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'util:constant',
            body: () => 42
          });

          const result = this.callFunction('util:constant', []);
          this.string(`${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('42');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should distinguish functions by arity', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          // Register two functions with same name but different arity
          this.function({
            name: 'f:greet',
            params: [{name: 'name'}],
            body: (name) => `Hello, ${name}!`
          });

          this.function({
            name: 'f:greet',
            params: [{name: 'title'}, {name: 'name'}],
            body: (title, name) => `Hello, ${title} ${name}!`
          });

          const result1 = this.callFunction('f:greet', ['Alice']);
          const result2 = this.callFunction('f:greet', ['Dr.', 'Smith']);
          this.string(`${result1} ${result2}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Hello, Alice!');
          expect(result).to.include('Hello, Dr. Smith!');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should throw error for duplicate function registration', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'f:test',
            params: [{name: 'x'}],
            body: (x) => x
          });

          try {
            this.function({
              name: 'f:test',
              params: [{name: 'y'}], // same arity
              body: (y) => y * 2
            });
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'already registered'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should throw error when calling undefined function', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          try {
            this.callFunction('f:undefined', [1, 2, 3]);
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'not found'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should throw error for wrong arity', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'f:test',
            params: [{name: 'x'}, {name: 'y'}],
            body: (x, y) => x + y
          });

          try {
            // Try calling with wrong number of arguments
            this.callFunction('f:test', [1]); // needs 2 args
            done(new Error('Should have thrown error'));
          } catch (err) {
            expect(/** @type {Error} */ (err).message).to.include(
              'not found'
            );
            done();
          }
        }
      }],
      success () {
        // No success callback needed - test ends in template
      }
    });
  });

  it('should return complex values', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'json',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'data:makeObject',
            params: [{name: 'key'}, {name: 'value'}],
            body: (key, value) => ({[key]: value})
          });

          const obj = this.callFunction('data:makeObject', ['name', 'Alice']);
          // eslint-disable-next-line unicorn/no-this-assignment -- Closure
          const that = this;
          this.object(function () {
            that.propValue('result', obj);
          });
        }
      }],
      success (result) {
        try {
          expect(result).to.deep.equal([{result: {name: 'Alice'}}]);
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should work with XPath context', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: '<root><item>5</item></root>',
      outputType: 'string',
      templates: [{
        path: '/root',
        template () {
          this.function({
            name: 'math:square',
            params: [{name: 'n'}],
            body: (n) => n * n
          });

          const value = Number(this.get('item', false));
          const result = this.callFunction('math:square', [value]);
          this.string(`${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('25');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should be callable from different templates', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {items: [1, 2, 3]},
      outputType: 'string',
      templates: [
        {
          path: '$',
          template () {
            // Register function once
            this.function({
              name: 'f:format',
              params: [{name: 'n'}],
              body: (n) => `[${n}]`
            });

            this.forEach('$.items[*]', function (item) {
              this.callTemplate({
                name: 'formatItem',
                withParam: [{name: 'value', value: item}]
              });
            });
          }
        },
        {
          name: 'formatItem',
          template () {
            const val = this.valueOf({select: '$value'});
            // Call function from different template
            const formatted = this.callFunction('f:format', [val]);
            this.string(`${formatted} `);
          }
        }
      ],
      success (result) {
        try {
          expect(result).to.equal('[1] [2] [3] ');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should support recursive functions', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          // Recursive factorial function
          // eslint-disable-next-line unicorn/no-this-assignment -- Closure
          const that = this;
          this.function({
            name: 'math:factorial',
            params: [{name: 'n'}],
            body (n) {
              if (n <= 1) {
                return 1;
              }
              // Recursive call via callFunction
              return n * that.callFunction('math:factorial', [n - 1]);
            }
          });

          const result = that.callFunction('math:factorial', [5]);
          that.string(`5! = ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.equal('5! = 120');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should handle functions with context access', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {threshold: 10},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          const threshold = this.get('$.threshold', false);

          this.function({
            name: 'app:isAboveThreshold',
            params: [{name: 'value'}],
            body: (value) => value > threshold
          });

          const result1 = this.callFunction('app:isAboveThreshold', [15]);
          const result2 = this.callFunction('app:isAboveThreshold', [5]);
          this.string(
            `15>${threshold}: ${result1}, 5>${threshold}: ${result2}`
          );
        }
      }],
      success (result) {
        try {
          expect(result).to.include('15>10: true');
          expect(result).to.include('5>10: false');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });

  it('should work with parameter type hints (as attribute)', (done) => {
    // eslint-disable-next-line no-new -- exercising API
    new JTLT({
      data: {},
      outputType: 'string',
      templates: [{
        path: '$',
        template () {
          this.function({
            name: 'str:length',
            params: [{name: 's', as: 'xs:string'}],
            as: 'xs:integer',
            body: (s) => String(s).length
          });

          const result = this.callFunction('str:length', ['hello']);
          this.string(`Length: ${result}`);
        }
      }],
      success (result) {
        try {
          expect(result).to.include('Length: 5');
          done();
        } catch (err) {
          done(err);
        }
      }
    });
  });
});
